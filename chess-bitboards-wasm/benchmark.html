<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WASM vs JS Benchmark</title>
    <style>
        body { font-family: monospace; padding: 20px; max-width: 1000px; margin: 0 auto; background: #f5f5f5; }
        h1 { color: #333; }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        button { padding: 12px 24px; font-size: 16px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; margin: 5px; }
        button:hover { background: #0056b3; }
        .result { margin: 15px 0; padding: 15px; background: #f8f9fa; border-left: 4px solid #007bff; }
        .wasm { border-left-color: #28a745; }
        .js { border-left-color: #ffc107; }
        .winner { background: #d4edda; border-left-color: #28a745; font-weight: bold; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background: #007bff; color: white; }
        .speedup { color: #28a745; font-weight: bold; }
        #output { white-space: pre-wrap; }
        .error { border-left-color: #dc3545; background: #f8d7da; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÅ WASM vs JavaScript Benchmark</h1>
        <p>Comparing chess bitboard operations: Rust/WASM vs Pure JavaScript</p>
        
        <div>
            <button id="quickBtn">Quick Benchmark (100k ops)</button>
            <button id="fullBtn">Full Benchmark (1M ops)</button>
            <button id="allBtn">All Operations</button>
        </div>
        
        <div id="output">Loading...</div>
    </div>

    <script src="../js/bitboard.js"></script>
    <script type="module">
        import init, { 
            popcount64, 
            lsb64, 
            msb64,
            knight_attacks as wasm_knight_attacks,
            king_attacks as wasm_king_attacks,
            rook_attacks as wasm_rook_attacks,
            bishop_attacks as wasm_bishop_attacks,
            white_pawn_attacks as wasm_white_pawn_attacks,
            ChessBitboardEngine
        } from './pkg/chess_bitboards_wasm.js';

        await init();

        const output = document.getElementById('output');
        let jsBoard;
        
        function log(html) {
            output.innerHTML += html;
        }

        function clear() {
            output.innerHTML = '';
        }
        
        // Initialize JS Board
        try {
            jsBoard = new BBBoard();
            jsBoard.loadFEN('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1');
            clear();
            log('<div class="result">‚úÖ JavaScript BBBoard initialized successfully</div>');
        } catch (error) {
            clear();
            log(`<div class="result error">‚ùå Error: ${error.message}</div>`);
            log('<div class="result error">Make sure js/bitboard.js is accessible from this location</div>');
        }
        
        // Attach event listeners
        document.getElementById('quickBtn').addEventListener('click', () => runBenchmark(100000));
        document.getElementById('fullBtn').addEventListener('click', () => runBenchmark(1000000));
        document.getElementById('allBtn').addEventListener('click', runAllOperations);
        
        function runAllOperations() {
            if (!jsBoard) {
                log('<div class="result error">‚ùå JS Board not initialized</div>');
                return;
            }
            
            clear();
            log('<h2>üìä Comprehensive Benchmark</h2>');
            
            const ops = [
                { name: 'Popcount', iterations: 1000000 },
                { name: 'LSB', iterations: 1000000 },
                { name: 'Knight Attacks', iterations: 500000 },
                { name: 'Rook Attacks', iterations: 200000 },
                { name: 'Bishop Attacks', iterations: 200000 }
            ];
            
            log('<table><tr><th>Operation</th><th>JS Time</th><th>WASM Time</th><th>Speedup</th></tr>');
            
            ops.forEach(op => {
                const result = benchmarkOperation(op.name, op.iterations);
                const speedup = (result.jsTime / result.wasmTime).toFixed(2);
                const speedupClass = speedup > 1 ? 'speedup' : '';
                
                log(`<tr>
                    <td>${op.name}</td>
                    <td>${result.jsTime.toFixed(2)}ms</td>
                    <td>${result.wasmTime.toFixed(2)}ms</td>
                    <td class="${speedupClass}">${speedup}x</td>
                </tr>`);
            });
            
            log('</table>');
        }

        function benchmarkOperation(name, iterations) {
            const square = 28; // e4
            const occupancy = 0n;
            const testValue = 0x123456789ABCDEFn;
            
            let jsTime, wasmTime;
            
            switch(name) {
                case 'Knight Attacks':
                    // JS
                    let start = performance.now();
                    for (let i = 0; i < iterations; i++) {
                        knightAttacks(square);
                    }
                    jsTime = performance.now() - start;
                    
                    // WASM
                    start = performance.now();
                    for (let i = 0; i < iterations; i++) {
                        wasm_knight_attacks(square);
                    }
                    wasmTime = performance.now() - start;
                    break;
                    
                case 'Rook Attacks':
                    // JS
                    start = performance.now();
                    for (let i = 0; i < iterations; i++) {
                        rookAttacks(square, occupancy);
                    }
                    jsTime = performance.now() - start;
                    
                    // WASM
                    start = performance.now();
                    for (let i = 0; i < iterations; i++) {
                        wasm_rook_attacks(square, occupancy);
                    }
                    wasmTime = performance.now() - start;
                    break;
                    
                case 'Bishop Attacks':
                    // JS
                    start = performance.now();
                    for (let i = 0; i < iterations; i++) {
                        bishopAttacks(square, occupancy);
                    }
                    jsTime = performance.now() - start;
                    
                    // WASM
                    start = performance.now();
                    for (let i = 0; i < iterations; i++) {
                        wasm_bishop_attacks(square, occupancy);
                    }
                    wasmTime = performance.now() - start;
                    break;
                    
                case 'Popcount':
                    // JS
                    start = performance.now();
                    for (let i = 0; i < iterations; i++) {
                        BBbitCount(testValue);
                    }
                    jsTime = performance.now() - start;
                    
                    // WASM
                    start = performance.now();
                    for (let i = 0; i < iterations; i++) {
                        popcount64(testValue);
                    }
                    wasmTime = performance.now() - start;
                    break;
                    
                case 'LSB':
                    // JS
                    start = performance.now();
                    for (let i = 0; i < iterations; i++) {
                        BBbitScanForward(testValue);
                    }
                    jsTime = performance.now() - start;
                    
                    // WASM
                    start = performance.now();
                    for (let i = 0; i < iterations; i++) {
                        lsb64(testValue);
                    }
                    wasmTime = performance.now() - start;
                    break;
            }
            
            return { jsTime, wasmTime };
        }

        function runBenchmark(iterations) {
            if (!jsBoard) {
                log('<div class="result error">‚ùå JS Board not initialized</div>');
                return;
            }
            
            clear();
            log(`<h2>üèÅ Benchmark Results (${iterations.toLocaleString()} iterations)</h2>`);
            
            const square = 28; // e4
            const occupancy = 0n;
            
            // Knight Attacks
            log('<div class="result js">');
            log('<strong>JavaScript - Knight Attacks</strong><br>');
            let start = performance.now();
            for (let i = 0; i < iterations; i++) {
                knightAttacks(square);
            }
            const jsKnightTime = performance.now() - start;
            log(`Time: ${jsKnightTime.toFixed(2)}ms<br>`);
            log(`Ops/sec: ${(iterations / jsKnightTime * 1000).toLocaleString()}</div>`);
            
            log('<div class="result wasm">');
            log('<strong>WASM - Knight Attacks</strong><br>');
            start = performance.now();
            for (let i = 0; i < iterations; i++) {
                wasm_knight_attacks(square);
            }
            const wasmKnightTime = performance.now() - start;
            log(`Time: ${wasmKnightTime.toFixed(2)}ms<br>`);
            log(`Ops/sec: ${(iterations / wasmKnightTime * 1000).toLocaleString()}</div>`);
            
            const knightSpeedup = (jsKnightTime / wasmKnightTime).toFixed(2);
            log(`<div class="result winner">üèÜ Speedup: ${knightSpeedup}x</div>`);
            
            // Rook Attacks
            log('<div class="result js">');
            log('<strong>JavaScript - Rook Attacks</strong><br>');
            start = performance.now();
            for (let i = 0; i < iterations; i++) {
                rookAttacks(square, occupancy);
            }
            const jsRookTime = performance.now() - start;
            log(`Time: ${jsRookTime.toFixed(2)}ms<br>`);
            log(`Ops/sec: ${(iterations / jsRookTime * 1000).toLocaleString()}</div>`);
            
            log('<div class="result wasm">');
            log('<strong>WASM - Rook Attacks</strong><br>');
            start = performance.now();
            for (let i = 0; i < iterations; i++) {
                wasm_rook_attacks(square, occupancy);
            }
            const wasmRookTime = performance.now() - start;
            log(`Time: ${wasmRookTime.toFixed(2)}ms<br>`);
            log(`Ops/sec: ${(iterations / wasmRookTime * 1000).toLocaleString()}</div>`);
            
            const rookSpeedup = (jsRookTime / wasmRookTime).toFixed(2);
            log(`<div class="result winner">üèÜ Speedup: ${rookSpeedup}x</div>`);
            
            // Summary
            log('<h3>üìà Summary</h3>');
            log('<table>');
            log('<tr><th>Operation</th><th>JS Time</th><th>WASM Time</th><th>Speedup</th></tr>');
            log(`<tr><td>Knight Attacks</td><td>${jsKnightTime.toFixed(2)}ms</td><td>${wasmKnightTime.toFixed(2)}ms</td><td class="speedup">${knightSpeedup}x</td></tr>`);
            log(`<tr><td>Rook Attacks</td><td>${jsRookTime.toFixed(2)}ms</td><td>${wasmRookTime.toFixed(2)}ms</td><td class="speedup">${rookSpeedup}x</td></tr>`);
            log('</table>');
        }
    </script>
</body>
</html>